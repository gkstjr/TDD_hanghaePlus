# 프로젝트: 동시성 제어 및 과제 분석
> **P.S.** 과제를 진행하면서 저의 고민하고 생각하는 과정을 기록하고 싶어 중간중간 보고서 형식의 말투가 아닌 부분이 있습니다... 귀엽게 봐주시면 정말 감사하겠습니다!! 😊
## 동시성 제어란?
- **동시성 제어**는 여러 쓰레드가 동시에 요청을 처리하는 환경에서 데이터의 일관성과 무결성을 보장하기 위한 프로그래밍 기법입니다.


- 여러 쓰레드가 동시에 접근할 때 경합 상태(Race Condition)나 데이터 손실 등의 문제를 방지하는 것이 핵심입니다.


- 제가 동시성 제어에 대해 쉽게 이해하기 좋았던 설명은 **“공유 자원에 여러 요청이 동시에 접근할 때 문제가 발생할 수 있으므로 동시성 제어가 필요하다”** 입니다.  
이 말은 즉 공유 자원이 없는 상황일 때는 동시성 제어가 필요하지 않다라는 것도 이해할 수 있었습니다. 
---

## 과제 분석

허재 코치님의 키워드 힌트를 바탕으로 구현 방법을 선택하며, 다음과 같은 과정을 거쳤습니다.
1. 순서대로 → 한 번에 하나의 요청 (가능)
2. 한 번에 하나의 요청 → 순서대로 (불가능 한 경우도 있음)
3. 오케이!! "그럼 한 번에 하나의 요청에 대해 구현하는데 집중한 후 응용해서 순서대로 요청도 해결 하는 순서로 진행해보자" 라는 생각을 했습니다.
### 요구사항 분석
1. **한 번에 하나의 요청 처리**
    - 같은 사용자에 대한 요청은 한 번에 하나만 처리되어야 합니다.
    - 다른 사용자에 대한 요청은 동시에 처리해도 무방합니다.
2. **순서대로 요청 처리** (저의 선택 기준은 현재 과제 환경에서 무엇이 가장 적합한가입니다.)
   - **클라이언트의 요청 시점?**
       - 클라이언트의 요청 객체에 시간 정보를 담아 테스트를 할 수 있지만 **클라이언트 → 서버 사이의 시간을 신뢰할 수 없다고 판단**해 이 방법은 **X**.
    - **서버가 요청을 받은 시점?**
       - 서버에서 직접 시간 정보를 기록할 수 있으므로 신뢰할 수 있다고 생각헸습니다.
       - 테스트 시 요청 객체에 수신 시간을 포함하고 이를 기준으로 순서 검증이 수월하다고 생각했습니다.
   - **락의 권한을 획득한 시점!!**
       - 우선 이 방법에 대한 기본 지식이 전혀 없어서 응용하는데 많은 시간 소모 예상.
       - 테스트 환경에서 락 획득 순서를 시뮬레이션하기 어렵다고 생각.
       - 어라? 그런데 학습을 해보니 **ReentrantLock의 공정성**을 설정하면 자동으로 **락 대기열에 먼저 들어온 스레드를 우선적으로 처리**할 수 있겠는데?
         - 이러면 '서버가 요청을 받은 시점'의 장점을 다 가져오면서 **큐 관리를 따로 하지 않아도 되지 않나? → 이거 럭키비키다. 선택!**
### 구현 방법

#### 1. 한 번에 하나의 요청 처리
- **ConcurrentHashMap + ReentrantLock**
    - 같은 사용자에 대한 요청 처리에 적합합니다.
    - 단점: 사용자가 많아질수록 메모리 사용량이 증가할 수 있으므로, 일정 시간이 지나면 사용되지 않는 Lock 객체를 제거하는 방법을 추후 구현 해 볼 생각입니다.

#### 2. 순서대로 요청 처리
- **ReentrantLock의 공정성(Fairness) 설정**
    - 락 대기열에 먼저 들어온 쓰레드를 우선적으로 처리할 수 있습니다.
    - 이를 통해 별도의 큐 관리 없이 순서 보장이 가능합니다.

---

## 과제 구현

### 요청 처리
1. **다른 사용자에 대한 요청**
    - 동시성 제어 없이 동시에 처리 가능하도록 구현.

2. **같은 사용자에 대한 요청**
    - 한 번에 하나의 요청 처리
        - `ConcurrentHashMap`과 `ReentrantLock`을 사용.
    - 순서대로 요청 처리
        - 서버의 요청 수신 시점을 기준으로 처리.
        - **ReentrantLock의 공정성 설정**을 활용하여 별도의 큐 관리 없이 구현.

### 동시성 제어 적용 위치 정하기
- **Controller?**
    - HTTP 요청을 처리하는 계층으로, 요청을 전달하는 역할에만 집중하도록 하자!
    - 동시성 제어는 비즈니스 로직과 밀접하므로 Controller 계층은 적합하지 않다고 판단했습니다.

- **Service!!**
    - 동시성 제어는 특정 비즈니스 로직(ex. 포인트 충전 / 사용)의 일관성을 보장하기 위해 필요.
    - Service 계층은 비즈니스 로직을 담당하므로 동시성 제어 코드를 재사용하기에 적합하다고 판단했습니다.

### 동시성 제어 통합 테스트

#### 1. 같은 사용자에 대한 요청 테스트
- **목적**: 동시성 제어를 통해 데이터 정합성이 보장되는지를 중요하게 생각했습니다.
- **방법**:
    - `ExecutorService`를 사용하여 여러 스레드에서 동시 요청 상황을 만듭니다.

#### 2. 같은 사용자에 대한 순차적 요청 테스트
- **목적**: 요청이 순차적으로 처리되는지 확인.
- **방법**:
    - `CountDownLatch`를 이용하여 스레드 요청 간의 대기 , 신호 명령을 하여 순서를 관리해주자.
- **동작 흐름**:
  - **충전 요청 흐름**
    1. `await()`로 이전 사용 요청이 끝났는지 확인.
    2. 충전 요청 실행.
    3. 충전 요청 완료 후 `countDown()` 호출 → 사용 요청으로 신호 전달.
  - **사용 요청 흐름**
      1. `await()`로 현재 충전 요청이 끝났는지 확인.
      2. 사용 요청 실행.
      3. 사용 요청 완료 후 `countDown()` 호출 → 다음 충전 요청으로 신호 전달.   
---

### 응용해보고 싶은 부분
- `CountDownLatch`를 특정 요청에 대해서는 더 많은 요청에 대해 대기를 정할 수 있겠다!  
→ ex.) 포인트 충전 선착순 이벤트 날 특정 사용자에게만 포인트 충전의 기회를 더 확보할 수 있게 해주는 상황.

---
